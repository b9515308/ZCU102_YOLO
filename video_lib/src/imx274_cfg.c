/******************************************************************************
 * (c) Copyright 2017 Xilinx, Inc. All rights reserved.
 *
 * This file contains confidential and proprietary information of Xilinx, Inc.
 * and is protected under U.S. and international copyright and other
 * intellectual property laws.
 *
 * DISCLAIMER
 * This disclaimer is not a license and does not grant any rights to the
 * materials distributed herewith. Except as otherwise provided in a valid
 * license issued to you by Xilinx, and to the maximum extent permitted by
 * applicable law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL
 * FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS,
 * IMPLIED, OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
 * MERCHANTABILITY, NON-INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE;
 * and (2) Xilinx shall not be liable (whether in contract or tort, including
 * negligence, or under any other theory of liability) for any loss or damage
 * of any kind or nature related to, arising under or in connection with these
 * materials, including for any direct, or any indirect, special, incidental,
 * or consequential loss or damage (including loss of data, profits, goodwill,
 * or any type of loss or damage suffered as a result of any action brought by
 * a third party) even if such damage or loss was reasonably foreseeable or
 * Xilinx had been advised of the possibility of the same.
 *
 * CRITICAL APPLICATIONS
 * Xilinx products are not designed or intended to be fail-safe, or for use in
 * any application requiring fail-safe performance, such as life-support or
 * safety devices or systems, Class III medical devices, nuclear facilities,
 * applications related to the deployment of airbags, or any other applications
 * that could lead to death, personal injury, or severe property or
 * environmental damage (individually and collectively, "Critical
 * Applications"). Customer assumes the sole risk and liability of any use of
 * Xilinx products in Critical Applications, subject only to applicable laws
 * and regulations governing limitations on product liability.
 *
 * THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE
 * AT ALL TIMES.
 *******************************************************************************/

#include <errno.h>
#include <fcntl.h>
#include <linux/i2c-dev-user.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <unistd.h>

#include "helper.h"
#include "gpio_utils.h"
#include "imx274_cfg.h"
#include "video_int.h"

#define I2C_SENSOR_DEV_STR	"/dev/i2c-0"
#define IMX274_SENSOR_ADDR	0x1A

#define GPIO_SENSOR_BASE_OFFSET	509
#define GPIO_CAM_RST		(GPIO_SENSOR_BASE_OFFSET + 0)

/* I2C sensor data structure */
struct i2c_regval {
	uint16_t addr;
	uint8_t data;
};

static const struct i2c_regval imx274_4l_2160p60_regs[] = {
	{ 0x3000, 0x12 },
	{ 0x3120, 0xF0 },
	{ 0x3121, 0x00 },
	{ 0x3122, 0x02 },
	{ 0x3129, 0x9C },
	{ 0x312A, 0x02 },
	{ 0x312D, 0x02 },
	{ 0x310B, 0x00 },
	{ 0x304C, 0x00 },
	{ 0x304D, 0x03 },
	{ 0x331C, 0x1A },
	{ 0x331D, 0x00 },
	{ 0x3502, 0x02 },
	{ 0x3529, 0x0E },
	{ 0x352A, 0x0E },
	{ 0x352B, 0x0E },
	{ 0x3538, 0x0E },
	{ 0x3539, 0x0E },
	{ 0x3553, 0x00 },
	{ 0x357D, 0x05 },
	{ 0x357F, 0x05 },
	{ 0x3581, 0x04 },
	{ 0x3583, 0x76 },
	{ 0x3587, 0x01 },
	{ 0x35BB, 0x0E },
	{ 0x35BC, 0x0E },
	{ 0x35BD, 0x0E },
	{ 0x35BE, 0x0E },
	{ 0x35BF, 0x0E },
	{ 0x366E, 0x00 },
	{ 0x366F, 0x00 },
	{ 0x3670, 0x00 },
	{ 0x3671, 0x00 },
	{ 0x3304, 0x32 },
	{ 0x3305, 0x00 },
	{ 0x3306, 0x32 },
	{ 0x3307, 0x00 },
	{ 0x3590, 0x32 },
	{ 0x3591, 0x00 },
	{ 0x3686, 0x32 },
	{ 0x3687, 0x00 },
	{ 0x3004, 0x01 },
	{ 0x3005, 0x01 },
	{ 0x3006, 0x00 },
	{ 0x3007, 0xA2 },
	{ 0x300C, 0xff },
	{ 0x300D, 0x00 },
	{ 0x300E, 0x00 },
	{ 0x300F, 0x00 },
	{ 0x3018, 0xA2 },
	{ 0x301A, 0x00 },
	{ 0x306B, 0x05 },
	{ 0x30E2, 0x01 },
	{ 0x30F6, 0x07 },
	{ 0x30F7, 0x01 },
	{ 0x30F8, 0xC6 },
	{ 0x30F9, 0x11 },
	{ 0x30FA, 0x00 },
	{ 0x30dd, 0x01 },
	{ 0x30de, 0x07 },
	{ 0x30df, 0x00 },
	{ 0x30e0, 0x03 },
	{ 0x30e1, 0x00 },
	{ 0x3037, 0x01 },
	{ 0x3038, 0x0c },
	{ 0x3039, 0x00 },
	{ 0x303a, 0x0c },
	{ 0x303b, 0x0f },
	{ 0x30EE, 0x01 },
	{ 0x3130, 0x78 },
	{ 0x3131, 0x08 },
	{ 0x3132, 0x70 },
	{ 0x3133, 0x08 },
	{ 0x3342, 0x0A },
	{ 0x3343, 0x00 },
	{ 0x3344, 0x16 },
	{ 0x3345, 0x00 },
	{ 0x33A6, 0x01 },
	{ 0x3528, 0x0E },
	{ 0x3554, 0x1F },
	{ 0x3555, 0x01 },
	{ 0x3556, 0x01 },
	{ 0x3557, 0x01 },
	{ 0x3558, 0x01 },
	{ 0x3559, 0x00 },
	{ 0x355A, 0x00 },
	{ 0x35BA, 0x0E },
	{ 0x366A, 0x1B },
	{ 0x366B, 0x1A },
	{ 0x366C, 0x19 },
	{ 0x366D, 0x17 },
	{ 0x3A41, 0x08 },
	{ 0x3012, 0x04 },
	{ 0x3000, 0x00 },
	{ 0x303E, 0x02 },
	{ 0x30F4, 0x00 },
	{ 0x3018, 0xA2 },
};

static const struct i2c_regval imx274_4l_2160p30_regs[] = {
	{ 0x3000, 0x12 },
	{ 0x3120, 0xF0 },
	{ 0x3121, 0x00 },
	{ 0x3122, 0x02 },
	{ 0x3129, 0x9C },
	{ 0x312A, 0x02 },
	{ 0x312D, 0x02 },
	{ 0x310B, 0x00 },
	{ 0x304C, 0x00 },
	{ 0x304D, 0x03 },
	{ 0x331C, 0x1A },
	{ 0x331D, 0x00 },
	{ 0x3502, 0x02 },
	{ 0x3529, 0x0E },
	{ 0x352A, 0x0E },
	{ 0x352B, 0x0E },
	{ 0x3538, 0x0E },
	{ 0x3539, 0x0E },
	{ 0x3553, 0x00 },
	{ 0x357D, 0x05 },
	{ 0x357F, 0x05 },
	{ 0x3581, 0x04 },
	{ 0x3583, 0x76 },
	{ 0x3587, 0x01 },
	{ 0x35BB, 0x0E },
	{ 0x35BC, 0x0E },
	{ 0x35BD, 0x0E },
	{ 0x35BE, 0x0E },
	{ 0x35BF, 0x0E },
	{ 0x366E, 0x00 },
	{ 0x366F, 0x00 },
	{ 0x3670, 0x00 },
	{ 0x3671, 0x00 },
	{ 0x3304, 0x32 },
	{ 0x3305, 0x00 },
	{ 0x3306, 0x32 },
	{ 0x3307, 0x00 },
	{ 0x3590, 0x32 },
	{ 0x3591, 0x00 },
	{ 0x3686, 0x32 },
	{ 0x3687, 0x00 },
	{ 0x3004, 0x01 },
	{ 0x3005, 0x01 },
	{ 0x3006, 0x00 },
	{ 0x3007, 0xA2 },
	{ 0x300C, 0xff },
	{ 0x300D, 0x00 },
	{ 0x300E, 0x00 },
	{ 0x300F, 0x00 },
	{ 0x3018, 0xA2 },
	{ 0x301A, 0x00 },
	{ 0x306B, 0x05 },
	{ 0x30E2, 0x01 },
	{ 0x30F6, 0xED },
	{ 0x30F7, 0x01 },
	{ 0x30F8, 0x08 },
	{ 0x30F9, 0x13 },
	{ 0x30FA, 0x00 },
	{ 0x30dd, 0x01 },
	{ 0x30de, 0x07 },
	{ 0x30df, 0x00 },
	{ 0x30e0, 0x03 },
	{ 0x30e1, 0x00 },
	{ 0x3037, 0x01 },
	{ 0x3038, 0x0c },
	{ 0x3039, 0x00 },
	{ 0x303a, 0x0c },
	{ 0x303b, 0x0f },
	{ 0x30EE, 0x01 },
	{ 0x3130, 0x78 },
	{ 0x3131, 0x08 },
	{ 0x3132, 0x70 },
	{ 0x3133, 0x08 },
	{ 0x3342, 0x0A },
	{ 0x3343, 0x00 },
	{ 0x3344, 0x16 },
	{ 0x3345, 0x00 },
	{ 0x33A6, 0x01 },
	{ 0x3528, 0x0E },
	{ 0x3554, 0x1F },
	{ 0x3555, 0x01 },
	{ 0x3556, 0x01 },
	{ 0x3557, 0x01 },
	{ 0x3558, 0x01 },
	{ 0x3559, 0x00 },
	{ 0x355A, 0x00 },
	{ 0x35BA, 0x0E },
	{ 0x366A, 0x1B },
	{ 0x366B, 0x1A },
	{ 0x366C, 0x19 },
	{ 0x366D, 0x17 },
	{ 0x3A41, 0x08 },
	{ 0x3012, 0x04 },
	{ 0x3000, 0x00 },
	{ 0x303E, 0x02 },
	{ 0x30F4, 0x00 },
	{ 0x3018, 0xA2 },
};

static const struct i2c_regval imx274_4l_1080p60_regs[] = {
	{ 0x3000, 0x12 },
	{ 0x3120, 0xF0 },
	{ 0x3121, 0x00 },
	{ 0x3122, 0x02 },
	{ 0x3129, 0x9C },
	{ 0x312A, 0x02 },
	{ 0x312D, 0x02 },
	{ 0x310B, 0x00 },
	{ 0x304C, 0x00 },
	{ 0x304D, 0x03 },
	{ 0x331C, 0x1A },
	{ 0x331D, 0x00 },
	{ 0x3502, 0x02 },
	{ 0x3529, 0x0E },
	{ 0x352A, 0x0E },
	{ 0x352B, 0x0E },
	{ 0x3538, 0x0E },
	{ 0x3539, 0x0E },
	{ 0x3553, 0x00 },
	{ 0x357D, 0x05 },
	{ 0x357F, 0x05 },
	{ 0x3581, 0x04 },
	{ 0x3583, 0x76 },
	{ 0x3587, 0x01 },
	{ 0x35BB, 0x0E },
	{ 0x35BC, 0x0E },
	{ 0x35BD, 0x0E },
	{ 0x35BE, 0x0E },
	{ 0x35BF, 0x0E },
	{ 0x366E, 0x00 },
	{ 0x366F, 0x00 },
	{ 0x3670, 0x00 },
	{ 0x3671, 0x00 },
	{ 0x3304, 0x32 },
	{ 0x3305, 0x00 },
	{ 0x3306, 0x32 },
	{ 0x3307, 0x00 },
	{ 0x3590, 0x32 },
	{ 0x3591, 0x00 },
	{ 0x3686, 0x32 },
	{ 0x3687, 0x00 },
	{ 0x3004, 0x02 },
	{ 0x3005, 0x21 },
	{ 0x3006, 0x00 },
	{ 0x3007, 0x11 },
	{ 0x300E, 0x01 },
	{ 0x300F, 0x00 },
	{ 0x301A, 0x00 },
	{ 0x306B, 0x05 },
	{ 0x30E2, 0x02 },
	{ 0x30F6, 0x04 },
	{ 0x30F7, 0x01 },
	{ 0x30F8, 0x06 },
	{ 0x30F9, 0x09 },
	{ 0x30FA, 0x00 },
	{ 0x30EE, 0x01 },
	{ 0x3130, 0x4E },
	{ 0x3131, 0x04 },
	{ 0x3132, 0x46 },
	{ 0x3133, 0x04 },
	{ 0x3342, 0x0A },
	{ 0x3343, 0x00 },
	{ 0x3344, 0x1A },
	{ 0x3345, 0x00 },
	{ 0x33A6, 0x01 },
	{ 0x3528, 0x0E },
	{ 0x3554, 0x00 },
	{ 0x3555, 0x01 },
	{ 0x3556, 0x01 },
	{ 0x3557, 0x01 },
	{ 0x3558, 0x01 },
	{ 0x3559, 0x00 },
	{ 0x355A, 0x00 },
	{ 0x35BA, 0x0E },
	{ 0x366A, 0x1B },
	{ 0x366B, 0x1A },
	{ 0x366C, 0x19 },
	{ 0x366D, 0x17 },
	{ 0x3A41, 0x08 },
	{ 0x3012, 0x03 },
	{ 0x3000, 0x00 },
	{ 0x303E, 0x02 },
	{ 0x30F4, 0x00 },
	{ 0x3018, 0xA2 },
};

static const struct i2c_regval imx274_4l_1080p30_regs[] = {
	{ 0x3000, 0x12 },
	{ 0x3120, 0xF0 },
	{ 0x3121, 0x00 },
	{ 0x3122, 0x02 },
	{ 0x3129, 0x9C },
	{ 0x312A, 0x02 },
	{ 0x312D, 0x02 },
	{ 0x310B, 0x00 },
	{ 0x304C, 0x00 },
	{ 0x304D, 0x03 },
	{ 0x331C, 0x1A },
	{ 0x331D, 0x00 },
	{ 0x3502, 0x02 },
	{ 0x3529, 0x0E },
	{ 0x352A, 0x0E },
	{ 0x352B, 0x0E },
	{ 0x3538, 0x0E },
	{ 0x3539, 0x0E },
	{ 0x3553, 0x00 },
	{ 0x357D, 0x05 },
	{ 0x357F, 0x05 },
	{ 0x3581, 0x04 },
	{ 0x3583, 0x76 },
	{ 0x3587, 0x01 },
	{ 0x35BB, 0x0E },
	{ 0x35BC, 0x0E },
	{ 0x35BD, 0x0E },
	{ 0x35BE, 0x0E },
	{ 0x35BF, 0x0E },
	{ 0x366E, 0x00 },
	{ 0x366F, 0x00 },
	{ 0x3670, 0x00 },
	{ 0x3671, 0x00 },
	{ 0x3304, 0x32 },
	{ 0x3305, 0x00 },
	{ 0x3306, 0x32 },
	{ 0x3307, 0x00 },
	{ 0x3590, 0x32 },
	{ 0x3591, 0x00 },
	{ 0x3686, 0x32 },
	{ 0x3687, 0x00 },
	{ 0x3004, 0x02 },
	{ 0x3005, 0x61 },
	{ 0x3006, 0x00 },
	{ 0x3007, 0x19 },
	{ 0x300E, 0x02 },
	{ 0x300F, 0x00 },
	{ 0x301A, 0x00 },
	{ 0x306B, 0x05 },
	{ 0x30E2, 0x02 },
	{ 0x30F6, 0x68 },
	{ 0x30F7, 0x01 },
	{ 0x30F8, 0xAC },
	{ 0x30F9, 0x08 },
	{ 0x30FA, 0x00 },
	{ 0x30EE, 0x01 },
	{ 0x3130, 0x4E },
	{ 0x3131, 0x04 },
	{ 0x3132, 0x46 },
	{ 0x3133, 0x04 },
	{ 0x3342, 0x0A },
	{ 0x3343, 0x00 },
	{ 0x3344, 0x1B },
	{ 0x3345, 0x00 },
	{ 0x33A6, 0x00 },
	{ 0x3528, 0x0E },
	{ 0x3554, 0x00 },
	{ 0x3555, 0x01 },
	{ 0x3556, 0x01 },
	{ 0x3557, 0x01 },
	{ 0x3558, 0x01 },
	{ 0x3559, 0x00 },
	{ 0x355A, 0x00 },
	{ 0x35BA, 0x0E },
	{ 0x366A, 0x1B },
	{ 0x366B, 0x19 },
	{ 0x366C, 0x17 },
	{ 0x366D, 0x17 },
	{ 0x3A41, 0x08 },
	{ 0x3012, 0x03 },
	{ 0x3000, 0x00 },
	{ 0x303E, 0x02 },
	{ 0x30F4, 0x00 },
	{ 0x3018, 0xA2 },
};

static const struct i2c_regval imx274_4l_720p60_regs[] = {
	{ 0x3000, 0x12 },
	{ 0x3120, 0xF0 },
	{ 0x3121, 0x00 },
	{ 0x3122, 0x02 },
	{ 0x3129, 0x9C },
	{ 0x312A, 0x02 },
	{ 0x312D, 0x02 },
	{ 0x310B, 0x00 },
	{ 0x304C, 0x00 },
	{ 0x304D, 0x03 },
	{ 0x331C, 0x1A },
	{ 0x331D, 0x00 },
	{ 0x3502, 0x02 },
	{ 0x3529, 0x0E },
	{ 0x352A, 0x0E },
	{ 0x352B, 0x0E },
	{ 0x3538, 0x0E },
	{ 0x3539, 0x0E },
	{ 0x3553, 0x00 },
	{ 0x357D, 0x05 },
	{ 0x357F, 0x05 },
	{ 0x3581, 0x04 },
	{ 0x3583, 0x76 },
	{ 0x3587, 0x01 },
	{ 0x35BB, 0x0E },
	{ 0x35BC, 0x0E },
	{ 0x35BD, 0x0E },
	{ 0x35BE, 0x0E },
	{ 0x35BF, 0x0E },
	{ 0x366E, 0x00 },
	{ 0x366F, 0x00 },
	{ 0x3670, 0x00 },
	{ 0x3671, 0x00 },
	{ 0x3304, 0x32 },
	{ 0x3305, 0x00 },
	{ 0x3306, 0x32 },
	{ 0x3307, 0x00 },
	{ 0x3590, 0x32 },
	{ 0x3591, 0x00 },
	{ 0x3686, 0x32 },
	{ 0x3687, 0x00 },
	{ 0x3004, 0x03 },
	{ 0x3005, 0x31 },
	{ 0x3006, 0x00 },
	{ 0x3007, 0x09 },
	{ 0x300E, 0x01 },
	{ 0x300F, 0x00 },
	{ 0x301A, 0x00 },
	{ 0x306B, 0x05 },
	{ 0x30E2, 0x03 },
	{ 0x30F6, 0x04 },
	{ 0x30F7, 0x01 },
	{ 0x30F8, 0x06 },
	{ 0x30F9, 0x09 },
	{ 0x30FA, 0x00 },
	{ 0x30EE, 0x01 },
	{ 0x3130, 0xE2 },
	{ 0x3131, 0x02 },
	{ 0x3132, 0xDE },
	{ 0x3133, 0x02 },
	{ 0x3342, 0x0A },
	{ 0x3343, 0x00 },
	{ 0x3344, 0x1B },
	{ 0x3345, 0x00 },
	{ 0x33A6, 0x01 },
	{ 0x3528, 0x0E },
	{ 0x3554, 0x00 },
	{ 0x3555, 0x01 },
	{ 0x3556, 0x01 },
	{ 0x3557, 0x01 },
	{ 0x3558, 0x01 },
	{ 0x3559, 0x00 },
	{ 0x355A, 0x00 },
	{ 0x35BA, 0x0E },
	{ 0x366A, 0x1B },
	{ 0x366B, 0x19 },
	{ 0x366C, 0x17 },
	{ 0x366D, 0x17 },
	{ 0x3A41, 0x04 },
	{ 0x3012, 0x03 },
	{ 0x3000, 0x00 },
	{ 0x303E, 0x02 },
	{ 0x30F4, 0x00 },
	{ 0x3018, 0xA2 },
};

static int i2c_write(int fd, const struct i2c_regval *reginfo)
{
	uint8_t data[4];

	data[0] = reginfo->addr & 0xff;
	data[1] = reginfo->data;
	return i2c_smbus_write_i2c_block_data(fd, reginfo->addr >> 8, 2, data);
}

static void imx274_reset(int rst)
{
	gpio_export(GPIO_CAM_RST);
	gpio_dir_out(GPIO_CAM_RST);
	gpio_act_low(GPIO_CAM_RST);
	gpio_value(GPIO_CAM_RST, rst);
	gpio_unexport(GPIO_CAM_RST);
}

int imx274_setup(unsigned int width, unsigned int height, unsigned int fps)
{
	int cnt, fd, ret;
	const struct i2c_regval *cfg;

	imx274_reset(0);

	if ((width == 3840) && (height == 2160) && (fps == 60 || !fps)) {
		cnt = ARRAY_SIZE(imx274_4l_2160p60_regs);
		cfg = imx274_4l_2160p60_regs;
	} else if ((width == 3840) && (height == 2160) && (fps == 30)) {
		cnt = ARRAY_SIZE(imx274_4l_2160p30_regs);
		cfg = imx274_4l_2160p30_regs;
	} else if ((width == 1920) && (height == 1080) && (fps == 60 || !fps)) {
		cnt = ARRAY_SIZE(imx274_4l_1080p60_regs);
		cfg = imx274_4l_1080p60_regs;
	} else if ((width == 1920) && (height == 1080) && (fps == 30)) {
		cnt = ARRAY_SIZE(imx274_4l_1080p30_regs);
		cfg = imx274_4l_1080p30_regs;
	} else if ((width == 1280) && (height == 720) && (fps == 60 || !fps)) {
		cnt = ARRAY_SIZE(imx274_4l_720p60_regs);
		cfg = imx274_4l_720p60_regs;
	} else {
		sprintf(vlib_errstr,
			"IMX274 does not support requested mode: '%dx%d-%dHz'",
			width, height, fps);
		vlib_info("Continue with previous mode\n");
		return VLIB_ERROR_NOT_SUPPORTED;
	}

	fd = open(I2C_SENSOR_DEV_STR, O_RDWR);
	if (fd < 0) {
		vlib_err("Error opening file: %s\n", strerror(errno));
		return VLIB_ERROR_FILE_IO;
	}

	ret = ioctl(fd, I2C_SLAVE, IMX274_SENSOR_ADDR);
	if (ret < 0) {
		vlib_err("Invalid i2c sensor addr 0x%x\n", IMX274_SENSOR_ADDR);
		goto err;
	}

	for (int i = 0; i < cnt; i++) {
		ret = i2c_write(fd, &cfg[i]);
		if (ret) {
			vlib_err("Write to sensor failed\n");
			goto err;
		}
	}

err:
	close(fd);
	return ret;
}

int imx274_start(void)
{
	return 0;
}

int imx274_stop(void)
{
	imx274_reset(1);

	return 0;
}
